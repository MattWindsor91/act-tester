// Package lifter contains the part of the tester framework that lifts litmus tests to compilable C.
// It does so by means of a backend HarnessMaker.
package lifter

import (
	"context"
	"os"

	"github.com/MattWindsor91/act-tester/internal/pkg/model"
	"github.com/sirupsen/logrus"
)

// HarnessMaker is an interface capturing the ability to make test harnesses.
type HarnessMaker interface {
	// MakeHarness asks the harness maker to make the test harness described by spec.
	// It returns a list outfiles of files created (C files, header files, etc.), and/or an error err.
	MakeHarness(spec model.HarnessSpec) (outFiles []string, err error)
}

// Lifter holds the main configuration for the lifter part of the tester framework.
type Lifter struct {
	// Plan is the plan on which this lifter is operating.
	Plan model.Plan

	// Maker is a harness maker.
	Maker HarnessMaker

	// OutDir contains the root output directory for things generated by this lifter.
	OutDir string
}

// LiftPlanFile loads a plan from file, runs the lifter on it, then outputs the plan to stdout.
func (l *Lifter) LiftPlanFile(ctx context.Context, file string) error {
	logrus.Infoln("loading plan from", file)
	if err := l.Plan.Load(file); err != nil {
		return err
	}
	if err := l.Lift(ctx); err != nil {
		return err
	}
	return l.Plan.Dump()
}

// Lift runs a lifting job: taking every test subject in a plan and using a backend to lift each into a test harness.
func (l *Lifter) Lift(ctx context.Context) error {
	logrus.Infoln("making output directory", l.OutDir)
	if err := os.Mkdir(l.OutDir, 0744); err != nil {
		return err
	}

	logrus.Infoln("now lifting")
	resCh := make(chan result)
	return l.Plan.ParMachines(ctx, func(ctx context.Context, m model.MachinePlan) error {
		return l.liftMachine(ctx, m, resCh)
	}, func(ctx context.Context) error {
		return handleResults(ctx, l.count(), resCh)
	})
}

func (l *Lifter) liftMachine(ctx context.Context, m model.MachinePlan, resCh chan<- result) error {
	dir, err := buildAndMkDir(l.OutDir, m.ID.Tags()...)
	if err != nil {
		return err
	}

	ml := machine{
		Corpus:  l.Plan.Corpus,
		Dir:     dir,
		Machine: m,
		Maker:   l.Maker,
		ResCh:   resCh,
	}
	return ml.lift(ctx)
}

// count counts the number of liftings that need doing.
func (l *Lifter) count() int {
	i := 0
	for _, m := range l.Plan.Machines {
		i += len(m.Arches())
	}
	return i * len(l.Plan.Corpus)
}
