// Package lifter contains the part of the tester framework that lifts litmus tests to compilable C.
// It does so by means of a backend HarnessMaker.
package lifter

import (
	"context"
	"os"

	"github.com/MattWindsor91/act-tester/internal/pkg/plan"

	"github.com/MattWindsor91/act-tester/internal/pkg/model"
	"github.com/sirupsen/logrus"
)

// HarnessMaker is an interface capturing the ability to make test harnesses.
type HarnessMaker interface {
	// MakeHarness asks the harness maker to make the test harness described by spec.
	// It returns a list outfiles of files created (C files, header files, etc.), and/or an error err.
	MakeHarness(spec model.HarnessSpec) (outFiles []string, err error)
}

// Lifter holds the main configuration for the lifter part of the tester framework.
type Lifter struct {
	// Plan is the plan on which this lifter is operating.
	Plan plan.Plan

	// Maker is a harness maker.
	Maker HarnessMaker

	// OutDir contains the root output directory for things generated by this lifter.
	OutDir string
}

// Run runs a lifting job: taking every test subject in a plan and using a backend to lift each into a test harness.
func (l *Lifter) Run(ctx context.Context, p *plan.Plan) (*plan.Plan, error) {
	if p == nil {
		return nil, plan.ErrNil
	}
	l.Plan = *p

	logrus.Infoln("making output directory", l.OutDir)
	if err := os.Mkdir(l.OutDir, 0744); err != nil {
		return nil, err
	}

	err := l.lift(ctx)
	return &l.Plan, err
}

func (l *Lifter) lift(ctx context.Context) error {
	logrus.Infoln("now lifting")
	resCh := make(chan result)
	return l.Plan.ParMachines(ctx, func(ctx context.Context, mid model.ID, m plan.MachinePlan) error {
		return l.liftMachine(ctx, mid, m, resCh)
	}, func(ctx context.Context) error {
		return handleResults(ctx, l.count(), resCh)
	})
}

func (l *Lifter) liftMachine(ctx context.Context, mid model.ID, m plan.MachinePlan, resCh chan<- result) error {
	dir, err := buildAndMkDir(l.OutDir, mid.Tags()...)
	if err != nil {
		return err
	}

	ml := machine{
		Corpus:    l.Plan.Corpus,
		Dir:       dir,
		MachineID: mid,
		Machine:   m,
		Maker:     l.Maker,
		ResCh:     resCh,
	}
	return ml.lift(ctx)
}

// count counts the number of liftings that need doing.
func (l *Lifter) count() int {
	i := 0
	for _, m := range l.Plan.Machines {
		i += len(m.Arches())
	}
	return i * len(l.Plan.Corpus)
}
