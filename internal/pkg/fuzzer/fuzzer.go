// Package director contains a test-plan fuzzer.
// It relies on the existence of a single-file fuzzer such as act-fuzz.
package fuzzer

import (
	"fmt"
	"math/rand"

	"github.com/MattWindsor91/act-tester/internal/pkg/model"
	"github.com/cheggaaa/pb/v3"
	"github.com/sirupsen/logrus"
)

// DefaultSubjectCycles is the default number of fuzz cycles to run per subject.
const DefaultSubjectCycles = 10

// SingleFuzzer represents types that can commune with a C litmus test fuzzer.
type SingleFuzzer interface {
	// FuzzSingle fuzzes the test at path inPath using the given seed,
	// outputting the new test to path outPath and the trace to tracePath.
	FuzzSingle(seed int32, inPath, outPath, tracePath string) error
}

// Fuzzer holds the configuration required to fuzz a plan file.
type Fuzzer struct {
	// Plan is the plan on which this fuzzer is operating.
	Plan model.Plan

	// Driver holds the single-file fuzzer that the fuzzer is going to use.
	Driver SingleFuzzer

	// OutDir contains the root output directory for things generated by this fuzzer.
	OutDir string

	// CorpusSize is the sampling size for the corpus after fuzzing.
	// It has a similar effect to CorpusSize in planner.Planner.
	CorpusSize int

	// SubjectCycles is the number of times to fuzz each file.
	SubjectCycles int
}

// FuzzPlanFile loads a plan from file, then runs the fuzzer on it.
func (f *Fuzzer) FuzzPlanFile(file string) error {
	logrus.Infoln("loading plan from", file)
	if err := f.Plan.Load(file); err != nil {
		return err
	}
	if err := f.Fuzz(); err != nil {
		return err
	}
	return f.Plan.Dump()
}

// Fuzz runs the fuzzer, sampling the results if needed.
func (f *Fuzzer) Fuzz() error {
	ps, err := f.prepare()
	if err != nil {
		return err
	}

	logrus.Infoln("now fuzzing")
	rng := rand.New(rand.NewSource(f.Plan.Seed))
	fcs, ferr := f.fuzzWithPathset(rng, ps)
	if ferr != nil {
		return ferr
	}

	return f.sampleAndUpdatePlan(fcs, rng)
}

// prepare does various pre-fuzzing checks and preparation steps.
func (f *Fuzzer) prepare() (*Pathset, error) {
	logrus.Infoln("checking viability")
	if err := f.checkViability(); err != nil {
		return nil, err
	}

	logrus.Infoln("preparing directories at", f.OutDir)
	ps, perr := f.setupPathset()
	if perr != nil {
		return nil, perr
	}
	return ps, nil
}

// sampleAndUpdatePlan samples fcs and places the result in the fuzzer's plan.
func (f *Fuzzer) sampleAndUpdatePlan(fcs model.Corpus, rng *rand.Rand) error {
	logrus.Infoln("sampling corpus")
	scs, err := fcs.Sample(rng.Int63(), f.CorpusSize)
	if err != nil {
		return err
	}

	logrus.Infoln("updating plan")
	f.Plan.Corpus = scs
	f.Plan.Seed = rng.Int63()
	return nil
}

func (f *Fuzzer) checkViability() error {
	if f.SubjectCycles <= 0 {
		return fmt.Errorf("%w: non-positive subject cycle amount", model.ErrSmallCorpus)
	}

	nsubjects, nruns := f.count()
	if nsubjects <= 0 {
		return model.ErrNoCorpus
	}

	// Note that this inequality 'does the right thing' when f.CorpusSize = 0, ie no corpus size requirement.
	if nruns < f.CorpusSize {
		return fmt.Errorf("%w: projected corpus size %d, want %d", model.ErrSmallCorpus, nruns, f.CorpusSize)
	}

	return nil
}

// count counts the number of subjects and individual fuzz runs to expect from this fuzzer.
func (f *Fuzzer) count() (nsubjects, nruns int) {
	nsubjects = len(f.Plan.Corpus)
	nruns = f.SubjectCycles * nsubjects
	return nsubjects, nruns
}

func (f *Fuzzer) fuzzWithPathset(rng *rand.Rand, ps *Pathset) (model.Corpus, error) {
	_, nfuzzes := f.count()

	fcs := make(model.Corpus, 0, nfuzzes)

	bar := pb.StartNew(nfuzzes)
	defer bar.Finish()

	for _, s := range f.Plan.Corpus {
		fc, err := f.fuzzSubject(s, ps, rng, bar)
		if err != nil {
			return nil, err
		}
		fcs = append(fcs, fc...)
	}

	return fcs, nil
}

// fuzzSubject fuzzes subject s with a seed generated by rng, storing according to ps and announcing progress on bar.
func (f *Fuzzer) fuzzSubject(s model.Subject, ps *Pathset, rng *rand.Rand, bar *pb.ProgressBar) (model.Corpus, error) {
	fuzzed := make(model.Corpus, f.SubjectCycles)

	for i := range fuzzed {
		outp, tracep := ps.OnSubject(s.Name, i)
		if err := f.Driver.FuzzSingle(rng.Int31(), s.Litmus, outp, tracep); err != nil {
			return nil, err
		}
		fuzzed[i] = model.Subject{
			Name:       CycledName(s.Name, i),
			OrigLitmus: s.Litmus,
			Litmus:     outp,
			TracePath:  tracep,
		}
		bar.Increment()
	}

	return fuzzed, nil
}

// setupPathset builds the Pathset to use for fuzzing, and makes its directories if they don't yet exist
func (f *Fuzzer) setupPathset() (*Pathset, error) {
	logrus.Infof("output directory: %s\n", f.OutDir)
	ps := NewPathset(f.OutDir)
	err := ps.Mkdirs()
	return ps, err
}
