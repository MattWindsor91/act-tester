// Package director contains a test-plan fuzzer.
// It relies on the existence of a single-file fuzzer such as act-fuzz.
package fuzzer

import (
	"context"
	"fmt"
	"math/rand"
	"runtime"

	"golang.org/x/sync/errgroup"

	"github.com/MattWindsor91/act-tester/internal/pkg/plan"

	"github.com/MattWindsor91/act-tester/internal/pkg/model"
	"github.com/cheggaaa/pb/v3"
	"github.com/sirupsen/logrus"
)

// DefaultSubjectCycles is the default number of fuzz cycles to run per subject.
const DefaultSubjectCycles = 10

// SingleFuzzer represents types that can commune with a C litmus test fuzzer.
type SingleFuzzer interface {
	// FuzzSingle fuzzes the test at path inPath using the given seed,
	// outputting the new test to path outPath and the trace to tracePath.
	FuzzSingle(seed int32, inPath, outPath, tracePath string) error
}

// Fuzzer holds the configuration required to fuzz a plan file.
type Fuzzer struct {
	// Plan is the plan on which this fuzzer is operating.
	Plan plan.Plan

	// Driver holds the single-file fuzzer that the fuzzer is going to use.
	Driver SingleFuzzer

	// OutDir contains the root output directory for things generated by this fuzzer.
	OutDir string

	// CorpusSize is the sampling size for the corpus after fuzzing.
	// It has a similar effect to CorpusSize in planner.Planner.
	CorpusSize int

	// SubjectCycles is the number of times to fuzz each file.
	SubjectCycles int
}

// Run runs the fuzzer, sampling the results if needed.
// Run is not thread-safe.
func (f *Fuzzer) Run(ctx context.Context, p *plan.Plan) (*plan.Plan, error) {
	if p == nil {
		return nil, plan.ErrNil
	}
	f.Plan = *p

	ps, err := f.prepare()
	if err != nil {
		return nil, err
	}

	logrus.Infoln("now fuzzing")
	rng := rand.New(rand.NewSource(f.Plan.Seed))
	fcs, ferr := f.fuzzWithPathset(ctx, rng, ps)
	if ferr != nil {
		return nil, ferr
	}

	return f.sampleAndUpdatePlan(fcs, rng)
}

// prepare does various pre-fuzzing checks and preparation steps.
func (f *Fuzzer) prepare() (*Pathset, error) {
	logrus.Infoln("checking viability")
	if err := f.checkViability(); err != nil {
		return nil, err
	}

	logrus.Infoln("preparing directories at", f.OutDir)
	ps, perr := f.setupPathset()
	if perr != nil {
		return nil, perr
	}
	return ps, nil
}

// sampleAndUpdatePlan samples fcs and places the result in the fuzzer's plan.
func (f *Fuzzer) sampleAndUpdatePlan(fcs model.Corpus, rng *rand.Rand) (*plan.Plan, error) {
	logrus.Infoln("sampling corpus")
	scs, err := fcs.Sample(rng.Int63(), f.CorpusSize)
	if err != nil {
		return nil, err
	}

	logrus.Infoln("updating plan")
	f.Plan.Corpus = scs
	f.Plan.Seed = rng.Int63()
	return &f.Plan, nil
}

func (f *Fuzzer) checkViability() error {
	if f.SubjectCycles <= 0 {
		return fmt.Errorf("%w: non-positive subject cycle amount", model.ErrSmallCorpus)
	}

	nsubjects, nruns := f.count()
	if nsubjects <= 0 {
		return model.ErrNoCorpus
	}

	// Note that this inequality 'does the right thing' when f.CorpusSize = 0, ie no corpus size requirement.
	if nruns < f.CorpusSize {
		return fmt.Errorf("%w: projected corpus size %d, want %d", model.ErrSmallCorpus, nruns, f.CorpusSize)
	}

	return nil
}

// count counts the number of subjects and individual fuzz runs to expect from this fuzzer.
func (f *Fuzzer) count() (nsubjects, nruns int) {
	nsubjects = len(f.Plan.Corpus)
	nruns = f.SubjectCycles * nsubjects
	return nsubjects, nruns
}

func (f *Fuzzer) fuzzWithPathset(ctx context.Context, rng *rand.Rand, ps *Pathset) (model.Corpus, error) {
	_, nfuzzes := f.count()

	fcs := make(model.Corpus, nfuzzes)

	eg, ectx := errgroup.WithContext(ctx)
	resCh := make(chan model.Subject)

	chunks := f.Plan.Corpus.Chunks(runtime.NumCPU())
	logrus.Infof("Fuzzing with %d chunks\n", len(chunks))

	for _, c := range chunks {
		cp := c
		subrng := rand.New(rand.NewSource(rng.Int63()))
		eg.Go(func() error {
			j := job{
				Corpus:        cp,
				Driver:        f.Driver,
				SubjectCycles: f.SubjectCycles,
				Pathset:       ps,
				Rng:           subrng,
				ResCh:         resCh,
			}
			return j.Fuzz(ectx)
		})
	}

	eg.Go(func() error {
		return handleResults(ectx, fcs, resCh)
	})
	err := eg.Wait()
	return fcs, err
}

func handleResults(ctx context.Context, fuzzed model.Corpus, resCh <-chan model.Subject) error {
	bar := pb.StartNew(len(fuzzed))
	defer bar.Finish()

	for i := range fuzzed {
		select {
		case fuzzed[i] = <-resCh:
			bar.Increment()
		case <-ctx.Done():
			return ctx.Err()
		}
	}

	return nil
}

// setupPathset builds the Pathset to use for fuzzing, and makes its directories if they don't yet exist
func (f *Fuzzer) setupPathset() (*Pathset, error) {
	logrus.Infof("output directory: %s\n", f.OutDir)
	ps := NewPathset(f.OutDir)
	err := ps.Mkdirs()
	return ps, err
}
